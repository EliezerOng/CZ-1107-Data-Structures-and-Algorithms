Q1 Write a function adjM2adjL() to convert an adjacency matrix to an adjacency list.

Q2 Write a function adjL2adjM() to convert an adjacency list to an adjacency matrix. Please reuse the
work down in Q1.

Q3 The degree of a vertex v of a graph is the number of edges incident on v. Write a function calDegreeV()
to compute vertex degrees using adjacent lists and using adjacency matrix.

void adjM2adjL(Graph *g)
{
    int i,j;
    ListNode **list;
    ListNode *temp;

    if(g->type==ADJ_LIST)
    {
        printf("Error");
        return;
    }
    if(g->V<=0)
    {
        printf("Empty Graph");
        return;
    }
    list = malloc(sizeof(ListNode *) * g->V);
    for(i = 0;i < g->V;i++)
    {
        list[i] = NULL;
    }
    for(i = 0;i < g->V;i++)
    {
        for(j = 0;j < g->V;j++)
        {
            if(g->adj.matrix[i][j] == 1)
            {
                if(list[i] == NULL)
                {
                    list[i] = malloc(sizeof(ListNode));
                    list[i]->vertex = j+1;
                    list[i]->next = NULL;
                    temp = list[i];
                }
                else
                {
                    temp->next = malloc(sizeof(ListNode));
                    temp->next->vertex = j+1;
                    temp->next->next = NULL;
                    temp = temp->next;
                }

            }
        }
    }
    g->type = ADJ_LIST;
    for(i = 0;i < g->V;i++)
    {
        free(g->adj.matrix[i]);
    }
    free(g->adj.matrix);
    g->adj.list = list;

}

void adjL2adjM(Graph *g)
{
    int i,j;
    ListNode *temp;
    if(g->type == ADJ_MATRIX)
        printf("Error");
    if(g->V<=0)
        printf("Empty Graph");

    int **mat = malloc(sizeof(int *) * g->V);
    for(i = 0;i<g->V;i++)
        mat[i] = malloc(sizeof(int) * g->V);


    for(i = 0;i < g->V;i++)
        for(j = 0;j < g->V;j++)
            mat[i][j] = 0;

    for(i = 0;i < g->V;i++)
    {
        temp = g->adj.list[i];
        while(temp != NULL)
        {
            mat[i][(temp->vertex)-1] = 1;
            temp = temp->next;
        }
    }
    g->type = ADJ_MATRIX;

    ListNode *next;
    for(i = 0;i < g->V;i++)
    {
        temp = g->adj.list[i];
        while(temp != NULL)
        {
            next = temp->next;
            free(temp);
            temp = temp->next;
        }
    }
    free(g->adj.list);
    g->adj.matrix = mat;



}

void calDegreeV(Graph g, int *degreeV)
{
    int i,j;
    ListNode *temp;

    if(g.type == ADJ_MATRIX)
    {
        for(i = 0;i < g.V;i++)
        {
            degreeV[i] = 0;
            for(j= 0;j < g.V;j++)
            {
                degreeV[i] += g.adj.matrix[i][j];

            }
        }
    }
    else
    {
        for(i = 0;i < g.V;i++)
        {
            degreeV[i] = 0;
            temp = g.adj.list[i];
            while(temp != NULL)
            {
                degreeV[i]++;
                temp = temp->next;
            }

        }
    }

}
