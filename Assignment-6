Q1 Modify the closed addressing hash table in Lab 6 Question 4 to perform insertion and deletion by using
a doubly linked list below.

Q2 Implement an open addressing hash table by double hashing to perform insertion and deletion. The
structure of hash slots is given below and a hash table with 37 hashslots is created in the main function.

Q3 Coalesced hashing is a combination of closed addressing and linear probing. Each slot is not only storing
the key, but also the link (index) to the next slot. The structure of hash slots is given below.

int HashInsert(HashTable* Q1Ptr, int key)
{
    ListNode *newnode = malloc(sizeof(ListNode));
    int ht = Hash(key , Q1Ptr->hSize);
    int num = Q1Ptr->Table[ht].size;
    if(num == 0)
    {
        newnode->key = key;
        newnode->next = newnode->pre = NULL;
        ++Q1Ptr->Table[ht].size;
        Q1Ptr->Table[ht].head = newnode;
        return 1;
    }
    else
    {
        ListNode *headlist = Q1Ptr->Table[ht].head;
        ListNode *temp = Q1Ptr->Table[ht].head;
        while(temp != NULL)
        {
            if(temp->key == key)
                return 0;
            temp = temp->next;
        }

        ++Q1Ptr->Table[ht].size;
        newnode->key = key;
        newnode->pre = NULL;

        newnode->next = headlist;
        headlist->pre = newnode;
        Q1Ptr->Table[ht].head = newnode;
        return 1;
    }


}

int HashDelete(HashTable* Q1Ptr, int key)
{
    int ht = Hash(key , Q1Ptr->hSize);
    if(Q1Ptr->Table[ht].size == 0)
        return 0;
    else
    {
        ListNode *cur = Q1Ptr->Table[ht].head;
        ListNode *pre;
        if(cur->key == key) //head of list is key
        {
            Q1Ptr->Table[ht].head = Q1Ptr->Table[ht].head->next;
            Q1Ptr->Table[ht].head->pre = NULL;
            free(cur);
            cur = NULL;
            return 1;
        }
        else
        {
            while(cur != NULL)
            {
                if(cur->key == key)
                    break;
                pre = cur;
                cur = cur->next;
            }
            if(cur == NULL) //item not in list
                return 0;
            if(cur->next == NULL) //if key is the last item of the list
            {
                pre->next = NULL;
                free(cur);
                cur = NULL;
                return 1;
            }
            else
            {
                pre->next = cur->next;
                cur->next->pre = pre;
                free(cur);
                cur = NULL;
                return 1;
            }
        }
    }
}

int HashInsert(int key, HashSlot hashTable[])
{
    int i;
    int j;
    int count = 0;
    int newkey = 0;
    int deletecount = 0;
    int emptykey = 0;
    for(i = 0;i < TABLESIZE;i++)
    {
        int ht = hash1(key + (i * hash2(key)));

        if(hashTable[ht].indicator == EMPTY)
        {
            emptykey = ht;
            break;
        }
        else if(hashTable[ht].indicator == USED)
        {
            if(hashTable[ht].key == key)
                return -1;
            else if(hashTable[ht].key != key)
                count += 1;
        }
        else if(hashTable[ht].indicator == DELETED)
        {
            if(deletecount == 0)
            {
                newkey = ht;
                deletecount++;
            }
            else
                continue;
        }
    }
    if(count < 37 && deletecount != 0)
    {
        hashTable[newkey].key = key;
        hashTable[newkey].indicator = USED;
        return count;
    }
    else if(count < 37 && deletecount == 0)
    {
        hashTable[emptykey].key = key;
        hashTable[emptykey].indicator = USED;
        return count;
    }
    return 37;
}

int HashDelete(int key, HashSlot hashTable[])
{
    int i;
    int j;
    int compare = 0;
    int newkey = 0;
    int k = 0;
    for(i = 0;i < TABLESIZE;i++)
    {
        int slot = hash1(key + (i*(hash2(key))));
        if(hashTable[slot].indicator == USED)
        {
            if(hashTable[slot].key != key)
            {
                compare += 1;
                continue;
            }
            else if(hashTable[slot].key == key)
            {
                k = 1;
                compare += 1;
                newkey = slot;
                break;
            }
        }
    }
    if(k == 1)
    {
        hashTable[newkey].indicator = DELETED;
        return compare;
    }
    else
        return -1;

}


int HashInsert(int key, HashSlot hashTable[])
{
    int slot;
    int count;
    int original;
    int slot2;
    slot = hash(key);
    if(hashTable[slot].indicator == EMPTY)
    {
        hashTable[slot].key = key;
        hashTable[slot].indicator = USED;
        return slot;
    }
    else
    {
        original = slot;
        if(hashTable[slot].next == -1)
        {
            if(hashTable[slot].key == key)
                return -1;
            while(hashTable[slot].indicator == USED)
            {
                slot += 1;
                count += 1;
                if(hashTable[slot].key == key)
                    return -1;
                if(slot == 37)
                    slot = 0;
                if(count == 37)
                    return 38;
            }
            hashTable[slot].key = key;
            hashTable[slot].indicator = USED;
            hashTable[original].next = slot;
            return slot;
        }
        else
        {
            if(hashTable[slot].key == key)
                return -1;
            while(hashTable[slot].next != -1)
            {
                slot = hashTable[slot].next;
                if(hashTable[slot].key == key)
                    return -1;
                slot2 = slot;
            }
            slot += 1;
            if(hashTable[slot].indicator == EMPTY)
            {
                hashTable[slot].key = key;
                hashTable[slot].indicator = USED;
                hashTable[slot2].next = slot;
                return slot;
            }
            else
            {
                while(hashTable[slot].indicator == USED)
                {
                    slot += 1;
                    count += 1;
                    if(hashTable[slot].key == key)
                        return -1;
                    if(slot == 37)
                        slot = 0;
                    if(count == 37)
                        return 38;
                }
                hashTable[slot].key = key;
                hashTable[slot].indicator = USED;
                hashTable[slot2].next = slot;
                return slot;
            }
        }
    }
}

int HashFind(int key, HashSlot hashTable[])
{
    int slot;
    slot = hash(key);
    if(hashTable[slot].key == key)
        return slot;
    else
    {
        while(hashTable[slot].key != key)
        {
            slot = hashTable[slot].next;
            if(slot == -1)
                return -1;
        }
        return slot;
    }

}
