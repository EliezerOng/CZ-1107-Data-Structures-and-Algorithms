Q1 Write a C program to convert an infix expression to a postfix expression. The input and the output of
the function are character strings. The input expression contains only four possible operators: +, -, *
and /. Operands can be any alphanumeric. Each operand is represented by a character symbol. The
parentheses are allowed in the input expression. You may assume that the expression is always valid.

void in2Post ( char * infix , char * postfix )

Q2 Write a C program to evaluate a postfix expression. You may assume that operands are single-digit
numbers. The function prototype is given below:

double exePostfix ( char * postfix )

Q3 Write a C program to convert an infix expression to a prefix expression.

void in2Pre ( char * infix , char * prefix )


void in2Post(char* infix, char* postfix)
{
    Stack s;
    s.head = NULL;
    s.size = 0;
    int i = 0;
    int y = 0;
    int op1;

    while(infix[i] != '\0')
    {
        if((infix[i] >= 65 && infix[i] <= 90) || (infix[i] >= 97 && infix[i] <= 122) || (infix[i] >= 49 && infix[i] <= 57))
        {
            postfix[y] = infix[i];
            y++;
        }
        else if(infix[i] == '(')
        {
            push(&s , infix[i]);
        }
        else if(infix[i] == ')')
        {
            while(peek(s) != '(')
            {
                op1 = peek(s);
                postfix[y] = op1;
                y++;
                pop(&s);
            }
            pop(&s);
        }
        else
        {
            while(!isEmptyStack(s) && peek(s) != '(' && precedence(peek(s) , infix[i]))
            {
                op1 = peek(s);
                postfix[y] = op1;
                y++;
                pop(&s);
            }
            push(&s , infix[i]);
        }

        i++;
    }
    while(!isEmptyStack(s))
    {
        op1 = peek(s);
        postfix[y] = op1;
        y++;
        pop(&s);
    }
}


double exePostfix(char* postfix)
{
	Stack s;
	s.head = NULL;
	s.size = 0;

	int i = 0;
	double op1 = 0;
	double op2 = 0;
	double op3 = 0;
	while(postfix[i] != '\0')
    {
        if(postfix[i] == '+' || postfix[i] == '-' || postfix[i] == '/' || postfix[i] == '*')
        {
            op2 = peek(s);
            pop(&s);
            op1 = peek(s);
            pop(&s);
            op3 = Evaluate((char)postfix[i] , op2 , op1);
            push(&s , op3);
        }
        else
        {
            op1 = postfix[i];
            push(&s , (op1 - 48));
        }
        i++;
    }
    return peek(s);
}

void in2Pre(char* infix, char* prefix)
{
    Stack s;
    s.head = NULL;
    s.size = 0;

    char revInfix[SIZE];
    char revPrefix[SIZE];
    int i=0;
    int j = 0;
    char c;
    int count =0;
    int op1;

    //reverse the string
    while(infix[count] != '\0')
        count++;
    for(i = count-1;i>=0;i--)
    {
        revInfix[count-1-i] = infix[i];
    }
    revInfix[count] = '\0';

    i = 0;
    while(revInfix[i] != '\0')
    {
        if((revInfix[i] >= 49 && revInfix[i] <= 57) || (revInfix[i] >= 65 && revInfix[i] <= 90) || (revInfix[i] >= 97 && revInfix[i] <= 122))
        {
            revPrefix[j++] = revInfix[i];
        }
        else if(revInfix[i] == ')')
            push(&s , revInfix[i]);
        else if(revInfix[i] == '(')
        {
            while(peek(s) != ')')
            {
                op1 = peek(s);
                revPrefix[j++] = op1;
                pop(&s);
            }
            pop(&s);
        }
        else
        {
            while(!isEmptyStack(s) && peek(s) != ')' && precedence(peek(s)) > precedence(revInfix[i]))
            {
                op1 = peek(s);
                revPrefix[j++] = op1;
                pop(&s);
            }
            push(&s , revInfix[i]);
        }
        i++;
    }
    while(!isEmptyStack(s))
    {
        op1 = peek(s);
        revPrefix[j++] = op1;
        pop(&s);
    }

    revPrefix[j] = '\0';
    count = 0;
    while(revPrefix[count] != '\0')
        count++;
    for(i = count-1;i>=0;i--)
    {
        prefix[count-i-1] = revPrefix[i];
    }
    prefix[count] = '\0';

}
